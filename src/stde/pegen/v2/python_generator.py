import ast
from keyword import iskeyword
import re
import token
from typing import TYPE_CHECKING, Any, Dict, List, Optional, Sequence, Set, Text, TextIO, Tuple, cast
from io import TextIOBase

from stde.pegen.v2.validator import ValidationError, validate_grammar

from stde.pegen.v2.grammar import (
    Action,
    Alt,
    Cut,
    Forced,
    Gather,
    GrammarVisitor,
    Group,
    Lookahead,
    TopLevelItem,
    NameLeaf,
    NegativeLookahead,
    Opt,
    PositiveLookahead,
    Repeat0,
    Repeat1,
    Rhs,
    Rule,
    StringLeaf,
    Grammar,
)
from stde.pegen.v2.parser_generator import ParserGenerator


#XXX: Should we change the shebang?
MODULE_PREFIX = """\
#!/usr/bin/env python
# @generated by stde.pegen from {filename}

from typing import Any, Optional
from stde.pegen.v2.parser import (
    memoize, memoize_left_rec, logger, DefaultParser, CharBasedParser,
    RuleResult, ResultFlag, NO_MATCH, FAILURE)
"""

# TODO: Can turn off class_name interpolation?
MODULE_SUFFIX = """

if __name__ == '__main__':
    from stde.pegen.v2.parser import simple_parser_main
    simple_parser_main({class_name})
"""

ADDITIONAL_TOKENS = {
    "SOFT_KEYWORD",
    # used in metagrammar to support Python 3.12 f-strings; don't exist in 3.11
    "FSTRING_START", "FSTRING_MIDDLE", "FSTRING_END",
}

ALLOWED_METAS = {"class", "base", "location_format", "metaheader",
                 "header", "trailer", "require"}

# TODO: Doc
# All v2 generators should accept the require string "v2".
ALLOWED_REQUIRES = {"v2", "v2-python"}


class InvalidNodeVisitor(GrammarVisitor[bool]): #?
    """TODO: Docstring"""
    def visit_NameLeaf(self, node: NameLeaf) -> bool:
        name = node.value
        return name.startswith("invalid")

    def visit_StringLeaf(self, node: StringLeaf) -> bool:
        return False

    def visit_TopLevelItem(self, node: TopLevelItem) -> bool:
        return self.visit(node.item)

    def visit_Rhs(self, node: Rhs) -> bool:
        return any(self.visit(alt) for alt in node.alts)

    def visit_Alt(self, node: Alt) -> bool:
        return any(self.visit(item) for item in node.items)

    def lookahead_call_helper(self, node: Lookahead) -> bool:
        return self.visit(node.node)

    def visit_PositiveLookahead(self, node: PositiveLookahead) -> bool:
        return self.lookahead_call_helper(node)

    def visit_NegativeLookahead(self, node: NegativeLookahead) -> bool:
        return self.lookahead_call_helper(node)

    def visit_Opt(self, node: Opt) -> bool:
        return self.visit(node.node)

    def visit_Repeat(self, node: Repeat0) -> Tuple[str, str]:
        return cast(Tuple[str, str], self.visit(node.node)) #?

    def visit_Gather(self, node: Gather) -> Tuple[str, str]:
        return cast(Tuple[str, str], self.visit(node.node)) #?

    def visit_Group(self, node: Group) -> bool:
        return self.visit(node.rhs)

    def visit_Cut(self, node: Cut) -> bool:
        return False

    def visit_Forced(self, node: Forced) -> bool:
        return self.visit(node.node)


#... with Parser
# TODO?
class PythonCallMakerVisitor(GrammarVisitor[Tuple[Optional[str], str]]):
    """Translates grammar items to a 2-tuple of
    - Capture variable name (None for no capture variable name) (`str | None`)
    - Matching code (`str`)

    Tuple[str | None, str] is the return type of all visitors.

    The capture variable names "cut" is special.
    """
    def __init__(self, parser_generator: "PythonParserGenerator"):
        self.gen = parser_generator
        self.cache: Dict[Any, Any] = {}
        self.keywords: Set[str] = set()
        self.soft_keywords: Set[str] = set()

    def visit_NameLeaf(self, node: NameLeaf) -> Tuple[Optional[str], str]:
        if node.value == "ENDMARKER":
            return None, "self.endmarker()"
        name = node.value.lower()
        if iskeyword(name):
            name += "_"
        return name, f"self.{name}()"

    def visit_StringLeaf(self, node: StringLeaf) -> Tuple[str, str]:
        val = ast.literal_eval(node.value)
        if re.match(r"[a-zA-Z_]\w*\Z", val):  # This is a keyword
            if node.value.endswith("'"):
                self.keywords.add(val)
            else:
                self.soft_keywords.add(val)
        return "literal", f"self.match_string({node.value})"

    def visit_Rhs(self, node: Rhs) -> Tuple[Optional[str], str]:
        if node in self.cache:
            return self.cache[node]
        if len(node.alts) == 1 and len(node.alts[0].items) == 1:
            self.cache[node] = self.visit(node.alts[0].items[0])
        else:
            name = self.gen.artificial_rule_from_rhs(node)
            self.cache[node] = name, f"self.{name}()"
        return self.cache[node]

    def visit_TopLevelItem(self, node: TopLevelItem) -> Tuple[Optional[str], str]:
        name, call = self.visit(node.item)
        if node.name:
            name = node.name
        return name, call

    def lookahead_call_helper(self, node: Lookahead) -> Tuple[str, str]:
        name, call = self.visit(node.node)
        head, tail = call.split("(", 1)
        assert tail[-1] == ")"
        tail = tail[:-1]
        return head, tail

    def visit_PositiveLookahead(self, node: PositiveLookahead) -> Tuple[None, str]:
        head, tail = self.lookahead_call_helper(node)
        return None, f"self.positive_lookahead({head}, {tail})"

    def visit_NegativeLookahead(self, node: NegativeLookahead) -> Tuple[None, str]:
        head, tail = self.lookahead_call_helper(node)
        return None, f"self.negative_lookahead({head}, {tail})"

    def visit_Opt(self, node: Opt) -> Tuple[str, str]:
        name, call = self.visit(node.node)
        # Note trailing comma (the call may already have one comma
        # at the end, for example when rules have both repeat0 and optional
        # markers, e.g: [rule*])
        # XXX: Still allow accessing "failed but accepted" state
        tempname = self.gen.dedupe_and_add_var("_temp")
        self.gen.action_ignore_variables.add(tempname)
        return ("opt", f"{tempname} if ({tempname} := ({call})) is not FAILURE "
                        "else NO_MATCH")

    def visit_Repeat0(self, node: Repeat0) -> Tuple[str, str]:
        if node in self.cache:
            return self.cache[node]
        name = self.gen.artificial_rule_from_repeat(node.node, False)
        self.cache[node] = name, f"self.{name}()"  # Also a trailing comma!
        return self.cache[node]

    def visit_Repeat1(self, node: Repeat1) -> Tuple[str, str]:
        if node in self.cache:
            return self.cache[node]
        name = self.gen.artificial_rule_from_repeat(node.node, True)
        self.cache[node] = name, f"self.{name}()"  # But no trailing comma here!
        return self.cache[node]

    def visit_Gather(self, node: Gather) -> Tuple[str, str]:
        if node in self.cache:
            return self.cache[node]
        name = self.gen.artificial_rule_from_gather(node)
        self.cache[node] = name, f"self.{name}()"  # No trailing comma here either!
        return self.cache[node]

    def visit_Group(self, node: Group) -> Tuple[Optional[str], str]:
        return self.visit(node.rhs)

    def visit_Cut(self, node: Cut) -> Tuple[str, str]:
        return "cut", "None"

    def visit_Forced(self, node: Forced) -> Tuple[str, str]:
        if isinstance(node.node, Group):
            _, expr = self.visit(node.node.rhs)
            return "forced", f"self.force({expr}, '''({node.node.rhs!s})''')"
        else:
            _, expr = self.visit(node.node)
            return "forced", f"self.force({expr}, {node.node.value!r})"


class UsedNamesVisitor(ast.NodeVisitor):
    """TODO: Docstring"""
    def generic_visit(self, node: ast.AST) -> Set[str]:
        result = set()
        for _, value in ast.iter_fields(node):
            if isinstance(value, list):
                for item in value:
                    if isinstance(item, ast.AST):
                        result.update(self.visit(item))
            elif isinstance(value, ast.AST):
                result.update(self.visit(value))
        return result

    def visit_Name(self, node: ast.Name) -> Set[str]:
        return {node.id}



def _check_grammar(grammar: Grammar) -> None:
    if not (m := set(grammar.metas.keys())) <= ALLOWED_METAS:
        raise ValidationError(f"Unrecognized metas: {','.join(m - ALLOWED_METAS)}")
    if "require" in grammar.metas and grammar.metas["require"] not in ALLOWED_REQUIRES:
        raise ValidationError("Grammar is not adapted for this parser generator "
                              f"(it requires {grammar.metas["require"]!r})")


#TODO: print indented text
class PythonParserGenerator(ParserGenerator, GrammarVisitor):
    def __init__(
        self,
        grammar: Grammar,
        tokens: Set[str] = set(token.tok_name.values()) | ADDITIONAL_TOKENS,
        unreachable_formatting: Optional[str] = None,
        *, # For maximum compatibility
        skip_actions: bool = False,
    ):
        # TODO: tokens customizable based on parser?
        # TODO: How to handle LOCATIONS?
        super().__init__(grammar, tokens)
        _check_grammar(self.grammar)
        validate_grammar(self.grammar)
        self.callmakervisitor: PythonCallMakerVisitor = PythonCallMakerVisitor(self) #pyright:ignore
        self._invalidvisitor: InvalidNodeVisitor = InvalidNodeVisitor()
        self._usednamesvisitor: UsedNamesVisitor = UsedNamesVisitor()
        self.unreachable_formatting = unreachable_formatting or "None  # pragma: no cover"
        self.location_formatting = self.grammar.metas.get("location_format",
            "lineno=start_lineno, col_offset=start_colno, "
            "end_lineno=end_lineno, end_col_offset=end_colno")
        self.return_cleanup_stmts: List[str] = []
        self.pre_action_stmts: List[str] = []
        self.action_ignore_variables: Set[str] = set()
        self.skip_actions = skip_actions

    def generate(self, file: TextIO, filename: str) -> None:
        super().generate(file, filename)
        metaheader = self.grammar.metas.get("metaheader", MODULE_PREFIX)
        if metaheader is not None:
            self.print(metaheader.rstrip("\n").format(filename=filename))
        header = self.grammar.metas.get("header", "")
        if header:
            self.print(header)
        cls_name = self.grammar.metas.get("class", "GeneratedParser")
        base_cls_name = self.grammar.metas.get("base", "DefaultParser")
        self.print("# Keywords and soft keywords are listed at the end of the parser definition.")
        self.print(f"class {cls_name}({base_cls_name}):")
        while self.todo:
            for rulename, rule in list(self.todo.items()):
                del self.todo[rulename]
                self.print()
                with self.indent():
                    self.visit(rule)

        self.print()
        with self.indent():
            self.print(f"KEYWORDS = {tuple(sorted(self.callmakervisitor.keywords))}")
            self.print(f"SOFT_KEYWORDS = {tuple(sorted(self.callmakervisitor.soft_keywords))}")

        trailer = self.grammar.metas.get("trailer", MODULE_SUFFIX.format(class_name=cls_name))
        if trailer is not None:
            self.print(trailer.rstrip("\n"))

    def alts_uses_locations(self, alts: Sequence[Alt]) -> bool:
        for alt in alts:
            if alt.action and "LOCATIONS" in alt.action:
                return True
            for item in map(lambda node: node.item, alt.items):
                if isinstance(item, Group) and self.alts_uses_locations(item.rhs.alts):
                    return True
        return False

    def add_return(self, ret_val: str) -> None:
        for stmt in self.return_cleanup_stmts:
            self.print(stmt)
        self.print(f"return {ret_val}")

    def visit_Rule(self, rule: Rule) -> None:
        is_loop = rule.is_loop()
        is_gather = rule.is_gather()
        rhs = rule.flatten()
        if rule.left_recursive:
            if rule.leader:
                self.print("@memoize_left_rec")
            else:
                # Non-leader rules in a cycle are not memoized,
                # but they must still be logged.
                self.print("@logger")
        else:
            self.print("@memoize")
        node_type = rule.type or "Any"
        self.print(f"def {rule.name}(self) -> RuleResult[{node_type}]:")
        with self.indent():
            self.print(f"# {rule.name}: {rhs}")
            if rule.nullable:
                self.print(f"# nullable")

            if rule.name.endswith("without_invalid"):
                self.print("_prev_call_invalid = self.call_invalid_rules")
                self.print("self.call_invalid_rules = False")
                self.return_cleanup_stmts.append("self.call_invalid_rules = _prev_call_invalid")

            self.print("mark = self.mark()")
            if self.alts_uses_locations(rule.rhs.alts):
                self.print("start_lineno, start_colno = self.start_of_rule_pos()")
                self.print("")
            if is_loop:
                self.print("children = []")
            self.visit(rhs, is_loop=is_loop, is_gather=is_gather)
            if rule.name.startswith("_loop0_"):
                # This feels okay, x* returning an empty list is not treated as failure,
                # which is perfectly valid as signaling matching no repetitions
                self.add_return("children")
            elif rule.name.startswith("_loop1_"):
                self.add_return("children or ResultFlag.FAILURE")
            else:
                self.add_return("FAILURE")

        if rule.name.endswith("without_invalid"):
            self.return_cleanup_stmts.pop()

    def visit_TopLevelItem(
        self, item: TopLevelItem, used: Optional[Set[str]], unreachable: bool
    ) -> None:
        """used: Actually used variables of action of belonging Alt.
        used == None when belonging Alt has no action.
        """
        name, call = self.callmakervisitor.visit(item.item)
        if unreachable:
            name = None
        elif item.name:
            name = item.name

        #TODO: Option to disable eliminating unused captures
        if used is not None and name not in used:
            name = None  # Eliminate unused capture

        if not name:
            # Parentheses are needed because the trailing comma may appear :> (XXX)
            self.print(f"({call}) is not FAILURE")
        else:
            if name == "cut":
                self.print(f"(cut := ({call}) is not FAILURE)")
            else:
                name = self.dedupe_and_add_var(name)
                name_r = self.dedupe_and_add_var("r_" + name)
                self.print(f"({name_r} := ({call})) is not FAILURE")
                self.pre_action_stmts.append(f"{name} = {name_r}")
                self.action_ignore_variables.add(name_r)

    def visit_Rhs(self, rhs: Rhs, is_loop: bool = False, is_gather: bool = False) -> None:
        if is_loop:
            assert len(rhs.alts) == 1
        for alt in rhs.alts:
            self.visit(alt, is_loop=is_loop, is_gather=is_gather)

    def print_action(
        self,
        action: Optional[str],
        locations: bool,
        unreachable: bool,
        is_gather: bool,
        is_loop: bool,
        has_invalid: bool,
    ) -> None:
        if not action:
            names = [name for name in self.local_variable_names if name not in self.action_ignore_variables]
            if is_gather:
                assert len(names) == 2
                action = f"[{names[0]}] + {names[1]}"
            else:
                if has_invalid:
                    assert unreachable
                    if TYPE_CHECKING: assert isinstance(action, str)
                else:
                    #...
                    if len(names) == 1:
                        action = f"{names[0]}"
                    else:
                        action = f"[{', '.join(names)}]"

        if locations:
            self.print("end_lineno, end_colno = self.end_of_rule_pos()")
            self.print("start = (start_lineno, start_colno)")
            self.print("end = (end_lineno, end_colno)")

        for stmt in self.pre_action_stmts:
            self.print(stmt)

        if is_loop:
            self.print(f"children.append({action})")
            self.print("mark = self.mark()")
        else:
            self.add_return(f"{action}")

    def visit_Alt(self, alt: Alt, is_loop: bool, is_gather: bool) -> None:
        has_cut = any(isinstance(item.item, Cut) for item in alt.items)
        has_invalid = self.has_invalid(alt)

        action_code = None if self.skip_actions else alt.action
        if action_code is None and not is_gather and has_invalid:
            action_code = "UNREACHABLE" #...

        locations = False
        unreachable = False
        used = None
        if action_code:
            # Replace magic name in the action_code rule
            if "LOCATIONS" in action_code:
                locations = True
                action_code = action_code.replace("LOCATIONS", self.location_formatting)
            if "UNREACHABLE" in action_code:
                unreachable = True
                action_code = action_code.replace("UNREACHABLE", self.unreachable_formatting)

            used = self.actually_used_names_in_action(action_code)
            if has_cut:
                used.add("cut")

        with self.local_variable_context():
            self.pre_action_stmts.clear()
            self.action_ignore_variables.clear()
            if has_cut:
                self.print("cut = False")
            if is_loop:
                self.print("while (")
            else:
                self.print("if (")
            with self.indent():
                first = True
                if has_invalid:
                    self.print("self.call_invalid_rules")
                    first = False
                for item in alt.items:
                    if first:
                        first = False
                    else:
                        self.print("and")
                    self.visit(item, used=used, unreachable=unreachable)
                    if is_gather:
                        self.print("is not None")

            self.print("):")
            with self.indent():
                # flake8 complains that visit_Alt is too complicated, so here we are :P
                self.print_action(action_code, locations, unreachable,
                                  is_gather, is_loop, has_invalid)

            self.print("self.reset(mark)")
            # Skip remaining alternatives if a cut was reached.
            if has_cut:
                self.print("if cut:")
                with self.indent():
                    self.add_return("FAILURE")

    def has_invalid(self, node: Any) -> bool:
        return self._invalidvisitor.visit(node)

    #...
    def actually_used_names_in_action(self, action: str) -> Set[str]:
        return self._usednamesvisitor.visit(ast.parse(action))
