#!/usr/bin/env python
# @generated by pegen from src/pegen/metagrammar_v2.gram

from typing import Any, Optional
from pegen.parser_v2 import memoize, memoize_left_rec, logger, DefaultParser, CharBasedParser
from ast import literal_eval
from typing import List, Union

from pegen.grammar import (
    Alt,
    GrammarItem,
    Cut,
    ExternDecl,
    Forced,
    Gather,
    Group,
    Item,
    Lookahead,
    LookaheadOrCut,
    MetaTuple,
    NameLeaf,
    TopLevelItem,
    NegativeLookahead,
    Opt,
    Plain,
    PositiveLookahead,
    Repeat0,
    Repeat1,
    Rhs,
    Rule,
    RuleName,
    Grammar,
    StringLeaf,
)

# Keywords and soft keywords are listed at the end of the parser definition.
class GeneratedParser(DefaultParser):

    @memoize
    def start(self) -> Optional[Grammar]:
        # start: grammar $
        mark = self.mark()
        if (
            (grammar := self.grammar())
            and
            (self.endmarker())
        ):
            return grammar
        self.reset(mark)
        return None

    @memoize
    def grammar(self) -> Optional[Grammar]:
        # grammar: metas? rules extern_rules?
        mark = self.mark()
        if (
            (metas := self.metas(),)
            and
            (rules := self.rules())
            and
            (extern_rules := self.extern_rules(),)
        ):
            return Grammar ( rules , extern_rules or [] , metas or [] )
        self.reset(mark)
        return None

    @memoize
    def metas(self) -> Optional[List [MetaTuple]]:
        # metas: meta metas | meta
        mark = self.mark()
        if (
            (meta := self.meta())
            and
            (metas := self.metas())
        ):
            return [meta] + metas
        self.reset(mark)
        if (
            (meta := self.meta())
        ):
            return [meta]
        self.reset(mark)
        return None

    @memoize
    def meta(self) -> Optional[MetaTuple]:
        # meta: "@" NAME NEWLINE | "@" NAME NAME NEWLINE | "@" NAME STRING NEWLINE
        mark = self.mark()
        if (
            (self.match_string("@"))
            and
            (name := self.name())
            and
            (self.newline())
        ):
            return ( name . string , None )
        self.reset(mark)
        if (
            (self.match_string("@"))
            and
            (a := self.name())
            and
            (b := self.name())
            and
            (self.newline())
        ):
            return ( a . string , b . string )
        self.reset(mark)
        if (
            (self.match_string("@"))
            and
            (name := self.name())
            and
            (string := self.string())
            and
            (self.newline())
        ):
            return ( name . string , literal_eval ( string . string ) )
        self.reset(mark)
        return None

    @memoize
    def rules(self) -> Optional[List [Rule]]:
        # rules: rule rules | rule
        mark = self.mark()
        if (
            (rule := self.rule())
            and
            (rules := self.rules())
        ):
            return [rule] + rules
        self.reset(mark)
        if (
            (rule := self.rule())
        ):
            return [rule]
        self.reset(mark)
        return None

    @memoize
    def rule(self) -> Optional[Rule]:
        # rule: rulename memoflag? ":" rule_rhs
        mark = self.mark()
        if (
            (rulename := self.rulename())
            and
            (opt := self.memoflag(),)
            and
            (self.match_string(":"))
            and
            (rule_rhs := self.rule_rhs())
        ):
            return Rule ( rulename [0] , rulename [1] , rule_rhs , memo = opt )
        self.reset(mark)
        return None

    @memoize
    def extern_rules(self) -> Optional[List [ExternDecl]]:
        # extern_rules: extern_rule extern_rules | extern_rule
        mark = self.mark()
        if (
            (extern_rule := self.extern_rule())
            and
            (extern_rules := self.extern_rules())
        ):
            return [extern_rule] + extern_rules
        self.reset(mark)
        if (
            (extern_rule := self.extern_rule())
        ):
            return [extern_rule]
        self.reset(mark)
        return None

    @memoize
    def extern_rule(self) -> Optional[ExternDecl]:
        # extern_rule: "extern" NAME annotation? NEWLINE
        mark = self.mark()
        if (
            (self.match_string("extern"))
            and
            (name := self.name())
            and
            (ann := self.annotation(),)
            and
            (self.newline())
        ):
            return ExternDecl ( name . string , ann )
        self.reset(mark)
        return None

    @memoize
    def rulename(self) -> Optional[RuleName]:
        # rulename: NAME annotation | NAME
        mark = self.mark()
        if (
            (name := self.name())
            and
            (annotation := self.annotation())
        ):
            return ( name . string , annotation )
        self.reset(mark)
        if (
            (name := self.name())
        ):
            return ( name . string , None )
        self.reset(mark)
        return None

    @memoize
    def rule_rhs(self) -> Optional[Rhs]:
        # rule_rhs: alts? NEWLINE INDENT more_alts DEDENT | NEWLINE INDENT alt NEWLINE DEDENT | alts NEWLINE
        mark = self.mark()
        if (
            (alts := self.alts(),)
            and
            (self.newline())
            and
            (self.indent())
            and
            (more_alts := self.more_alts())
            and
            (self.dedent())
        ):
            return Rhs ( alts . alts + more_alts . alts ) if alts else more_alts
        self.reset(mark)
        if (
            (self.newline())
            and
            (self.indent())
            and
            (alt := self.alt())
            and
            (self.newline())
            and
            (self.dedent())
        ):
            return Rhs ( [alt] )
        self.reset(mark)
        if (
            (alts := self.alts())
            and
            (self.newline())
        ):
            return alts
        self.reset(mark)
        return None

    @memoize
    def memoflag(self) -> Optional[str]:
        # memoflag: '(' "memo" ')'
        mark = self.mark()
        if (
            (self.match_string('('))
            and
            (self.match_string("memo"))
            and
            (self.match_string(')'))
        ):
            return "memo"
        self.reset(mark)
        return None

    @memoize
    def alts(self) -> Optional[Rhs]:
        # alts: alt "|" alts | alt
        mark = self.mark()
        if (
            (alt := self.alt())
            and
            (self.match_string("|"))
            and
            (alts := self.alts())
        ):
            return Rhs ( [alt] + alts . alts )
        self.reset(mark)
        if (
            (alt := self.alt())
        ):
            return Rhs ( [alt] )
        self.reset(mark)
        return None

    @memoize
    def more_alts(self) -> Optional[Rhs]:
        # more_alts: "|" alts NEWLINE more_alts | "|" alts NEWLINE
        mark = self.mark()
        if (
            (self.match_string("|"))
            and
            (alts := self.alts())
            and
            (self.newline())
            and
            (more_alts := self.more_alts())
        ):
            return Rhs ( alts . alts + more_alts . alts )
        self.reset(mark)
        if (
            (self.match_string("|"))
            and
            (alts := self.alts())
            and
            (self.newline())
        ):
            return Rhs ( alts . alts )
        self.reset(mark)
        return None

    @memoize
    def alt(self) -> Optional[Alt]:
        # alt: items '$' action | items '$' | items action | items | '$'
        mark = self.mark()
        if (
            (items := self.items())
            and
            (self.match_string('$'))
            and
            (action := self.action())
        ):
            return Alt ( items + [TopLevelItem ( None , NameLeaf ( 'ENDMARKER' ) )] , action = action )
        self.reset(mark)
        if (
            (items := self.items())
            and
            (self.match_string('$'))
        ):
            return Alt ( items + [TopLevelItem ( None , NameLeaf ( 'ENDMARKER' ) )] , action = None )
        self.reset(mark)
        if (
            (items := self.items())
            and
            (action := self.action())
        ):
            return Alt ( items , action = action )
        self.reset(mark)
        if (
            (items := self.items())
        ):
            return Alt ( items , action = None )
        self.reset(mark)
        if (
            (self.match_string('$'))
        ):
            return Alt ( [] , action = None )
        self.reset(mark)
        return None

    @memoize
    def items(self) -> Optional[List [TopLevelItem]]:
        # items: top_level_item items | top_level_item
        mark = self.mark()
        if (
            (top_level_item := self.top_level_item())
            and
            (items := self.items())
        ):
            return [top_level_item] + items
        self.reset(mark)
        if (
            (top_level_item := self.top_level_item())
        ):
            return [top_level_item]
        self.reset(mark)
        return None

    @memoize
    def top_level_item(self) -> Optional[TopLevelItem]:
        # top_level_item: NAME annotation '=' ~ item | NAME '=' ~ item | item | top_level_others
        mark = self.mark()
        cut = False
        if (
            (name := self.name())
            and
            (annotation := self.annotation())
            and
            (self.match_string('='))
            and
            (cut := True)
            and
            (item := self.item())
        ):
            return TopLevelItem ( name . string , item , annotation )
        self.reset(mark)
        if cut:
            return None
        cut = False
        if (
            (name := self.name())
            and
            (self.match_string('='))
            and
            (cut := True)
            and
            (item := self.item())
        ):
            return TopLevelItem ( name . string , item )
        self.reset(mark)
        if cut:
            return None
        if (
            (item := self.item())
        ):
            return TopLevelItem ( None , item )
        self.reset(mark)
        if (
            (it := self.top_level_others())
        ):
            return TopLevelItem ( None , it )
        self.reset(mark)
        return None

    @memoize
    def top_level_others(self) -> Optional[LookaheadOrCut]:
        # top_level_others: '&' '&' ~ atom | '&' ~ atom | '!' ~ atom | '~'
        mark = self.mark()
        cut = False
        if (
            (self.match_string('&'))
            and
            (self.match_string('&'))
            and
            (cut := True)
            and
            (atom := self.atom())
        ):
            return Forced ( atom )
        self.reset(mark)
        if cut:
            return None
        cut = False
        if (
            (self.match_string('&'))
            and
            (cut := True)
            and
            (atom := self.atom())
        ):
            return PositiveLookahead ( atom )
        self.reset(mark)
        if cut:
            return None
        cut = False
        if (
            (self.match_string('!'))
            and
            (cut := True)
            and
            (atom := self.atom())
        ):
            return NegativeLookahead ( atom )
        self.reset(mark)
        if cut:
            return None
        if (
            (self.match_string('~'))
        ):
            return Cut ( )
        self.reset(mark)
        return None

    @memoize
    def item(self) -> Optional[Item]:
        # item: '[' ~ alts ']' | atom '?' | atom '*' | atom '+' | atom '.' atom '+' | atom
        mark = self.mark()
        cut = False
        if (
            (self.match_string('['))
            and
            (cut := True)
            and
            (alts := self.alts())
            and
            (self.match_string(']'))
        ):
            return Opt ( alts )
        self.reset(mark)
        if cut:
            return None
        if (
            (atom := self.atom())
            and
            (self.match_string('?'))
        ):
            return Opt ( atom )
        self.reset(mark)
        if (
            (atom := self.atom())
            and
            (self.match_string('*'))
        ):
            return Repeat0 ( atom )
        self.reset(mark)
        if (
            (atom := self.atom())
            and
            (self.match_string('+'))
        ):
            return Repeat1 ( atom )
        self.reset(mark)
        if (
            (sep := self.atom())
            and
            (self.match_string('.'))
            and
            (node := self.atom())
            and
            (self.match_string('+'))
        ):
            return Gather ( sep , node )
        self.reset(mark)
        if (
            (atom := self.atom())
        ):
            return atom
        self.reset(mark)
        return None

    @memoize
    def atom(self) -> Optional[Plain]:
        # atom: '(' ~ alts ')' | NAME | STRING
        mark = self.mark()
        cut = False
        if (
            (self.match_string('('))
            and
            (cut := True)
            and
            (alts := self.alts())
            and
            (self.match_string(')'))
        ):
            return Group ( alts )
        self.reset(mark)
        if cut:
            return None
        if (
            (name := self.name())
        ):
            return NameLeaf ( name . string )
        self.reset(mark)
        if (
            (string := self.string())
        ):
            return StringLeaf ( string . string )
        self.reset(mark)
        return None

    @memoize
    def action(self) -> Optional[str]:
        # action: "{" ~ target_atoms "}"
        mark = self.mark()
        cut = False
        if (
            (self.match_string("{"))
            and
            (cut := True)
            and
            (target_atoms := self.target_atoms())
            and
            (self.match_string("}"))
        ):
            return target_atoms
        self.reset(mark)
        if cut:
            return None
        return None

    @memoize
    def annotation(self) -> Optional[str]:
        # annotation: "[" ~ target_atoms "]"
        mark = self.mark()
        cut = False
        if (
            (self.match_string("["))
            and
            (cut := True)
            and
            (target_atoms := self.target_atoms())
            and
            (self.match_string("]"))
        ):
            return target_atoms
        self.reset(mark)
        if cut:
            return None
        return None

    @memoize
    def target_atoms(self) -> Optional[str]:
        # target_atoms: target_atom target_atoms | target_atom
        mark = self.mark()
        if (
            (target_atom := self.target_atom())
            and
            (target_atoms := self.target_atoms())
        ):
            return target_atom + " " + target_atoms
        self.reset(mark)
        if (
            (target_atom := self.target_atom())
        ):
            return target_atom
        self.reset(mark)
        return None

    @memoize
    def target_atom(self) -> Optional[str]:
        # target_atom: "{" ~ target_atoms? "}" | "[" ~ target_atoms? "]" | NAME "*" | NAME | NUMBER | STRING | FSTRING_START target_fstring_middle* FSTRING_END | "?" | ":" | !"}" !"]" OP
        mark = self.mark()
        cut = False
        if (
            (self.match_string("{"))
            and
            (cut := True)
            and
            (atoms := self.target_atoms(),)
            and
            (self.match_string("}"))
        ):
            return "{" + ( atoms or "" ) + "}"
        self.reset(mark)
        if cut:
            return None
        cut = False
        if (
            (self.match_string("["))
            and
            (cut := True)
            and
            (atoms := self.target_atoms(),)
            and
            (self.match_string("]"))
        ):
            return "[" + ( atoms or "" ) + "]"
        self.reset(mark)
        if cut:
            return None
        if (
            (name := self.name())
            and
            (self.match_string("*"))
        ):
            return name . string + "*"
        self.reset(mark)
        if (
            (name := self.name())
        ):
            return name . string
        self.reset(mark)
        if (
            (number := self.number())
        ):
            return number . string
        self.reset(mark)
        if (
            (string := self.string())
        ):
            return string . string
        self.reset(mark)
        if (
            (l := self.fstring_start())
            and
            (m := self._loop0_1(),)
            and
            (r := self.fstring_end())
        ):
            return l . string + "" . join ( m ) + r . string
        self.reset(mark)
        if (
            (self.match_string("?"))
        ):
            return "?"
        self.reset(mark)
        if (
            (self.match_string(":"))
        ):
            return ":"
        self.reset(mark)
        if (
            (self.negative_lookahead(self.match_string, "}"))
            and
            (self.negative_lookahead(self.match_string, "]"))
            and
            (op := self.op())
        ):
            return op . string
        self.reset(mark)
        return None

    @memoize
    def target_fstring_middle(self) -> Optional[str]:
        # target_fstring_middle: FSTRING_MIDDLE | "{" | "}" | target_atom
        mark = self.mark()
        if (
            (fstring_middle := self.fstring_middle())
        ):
            return fstring_middle . string
        self.reset(mark)
        if (
            (self.match_string("{"))
        ):
            return "{"
        self.reset(mark)
        if (
            (self.match_string("}"))
        ):
            return "}"
        self.reset(mark)
        if (
            (target_atom := self.target_atom())
        ):
            return target_atom
        self.reset(mark)
        return None

    @memoize
    def _loop0_1(self) -> Optional[Any]:
        # _loop0_1: target_fstring_middle
        mark = self.mark()
        children = []
        while (
            (target_fstring_middle := self.target_fstring_middle())
        ):
            children.append(target_fstring_middle)
            mark = self.mark()
        self.reset(mark)
        return children

    KEYWORDS = ()
    SOFT_KEYWORDS = ('extern', 'memo')


if __name__ == '__main__':
    from pegen.parser_v2 import simple_parser_main
    simple_parser_main(GeneratedParser)
